---
title: "Data Assembly and Cleaning"
toc: true
---

## Data Sources

Our EV charger location data comes from the National Renewable Energy Laboratory's (NREL) [alternative fuel stations database API](https://developer.nrel.gov/docs/transportation/alt-fuel-stations-v1/). The publicly available database lists all public and private EV chargers in the U.S, including their latitude and longitude. We supplement this data with demographic variables from the 5 year American Community Survey, accessed via the Census API via tidycensus. 

## Pulling the NREL Charger Data

```{r}
#load libraries
library(tidyverse)
library(httr)
library(jsonlite)
library(janitor)
library(tidycensus)
library(tigris)
library(sf)
```

Because we are dealing with a large data set and several API calls, the following code is wrapped in if statements, such that API calls will only be made if the data is not already stored on locally. `refresh_data_chargers` and `refresh_data_acs` allow for a manual override. 

Data is stored in the subdirectory `/data`, which is created if it doesn't exist already.

```{r}
if (!dir.exists("data")) dir.create("data")

refresh_data_chargers <-FALSE # set to TRUE to re-pull charger data
refresh_data_acs <- FALSE # set to TRUE if to re-pull ACS data

```

The code block below loads the API key and constructs a GET call to collect data on all public AV chargers in the US. In addition to their locations, the query also selects several variables about the chargers, which we ultimately did not end up using in this analysis. 

After confirming a successful response, the incoming JSON is parsed and converted into a dataframe, chargers. The latitude and longitude of each charger are then used to create point geometries. The coordinate reference system is reprojected to EPSG:5070 to allow distance calculations in meters. Buffers are applied around each charger point to account for the fact that chargers can serve nearby census tracts even when they do not fall directly within tract boundaries. We use a 1-mile buffer to define access, consistent with [NEVI guidelines](https://www.ibtta.org/sites/default/files/documents/Advocacy/IBTTA-NEVI-Program-Guide-FINAL-2022-0328.pdf) that place corridor fast chargers within 1 mile of a highway. Anchoring the buffer to this standard avoids an arbitrary cutoff and makes the access measure easier to interpret.

The resulting dataframe is then stored locally for future access. 

```{r}

if (file.exists("data/chargers_sf.rds") && 
    file.exists("data/chargers_buffers_1mi.rds") && 
    !refresh_data_chargers)
{
  chargers_sf <- read_rds("data/chargers_sf.rds")
  chargers_buffers_1mi <- read_rds("data/chargers_buffers_1mi.rds")
} else {
  
  #Read API Key from env file
  nrel_key <- Sys.getenv("NREL_API_KEY")
  
  # Build and Send Request
  base_url <- "https://developer.nrel.gov/api/alt-fuel-stations/v1.json"
  
  params <- list(
    api_key = nrel_key,
    fuel_type = "ELEC", # electric
    access = "public", # public access_code
    country = "US", # US stations
    status = "E", # only available stations
    limit  = "all" 
  )
  
  chargers_json <- GET(base_url, query = params)
  
  # Check the response
  http_status(chargers_json)
  
  #parse the response
  chargers_text_json <- content(chargers_json, as = "text")
  chargers_parsed_json <- fromJSON(chargers_text_json, flatten = TRUE)
  chargers <- as_tibble(chargers_parsed_json$fuel_stations)
  
  chargers <- chargers |>
    select(
      id,
      station_name,
      street_address,
      city, 
      state,
      zip,
      plus4,
      restricted_access,
      access_detail_code,
      owner_type_code,
      facility_type,
      ev_level1_evse_num,
      ev_level2_evse_num,
      ev_connector_types,
      ev_network,
      ev_renewable_source,
      funding_sources,
      geocode_status,
      latitude,
      longitude,
      open_date
    )
  
  # turn latitude and longitude into geometries
  chargers_sf <- chargers |>
    # drop rows with missing coords
    filter(!is.na(latitude), !is.na(longitude)) |>
    st_as_sf(
      coords = c("longitude", "latitude"),  
      crs    = 4326,                        
      remove = FALSE                       
    )
  
  chargers_sf <- st_transform(chargers_sf, 5070) #change to projected CRS in meters, for buffers
  
  chargers_buffers_1mi <- st_buffer(chargers_sf, dist = 1609.34) #creates one mile buffers
  
  #cache locally to avoid repeat pulls
  write_rds(chargers_sf, "data/chargers_sf.rds")
  write_rds(chargers_buffers_1mi, "data/chargers_buffers_1mi.rds")
}
```

## Pulling the ACS Data and Tract Geometries

We then construct a tract-level demographic dataset from the 2023 ACS 5-year survey to provide additional demographic information about each census tract. Again we check for a previous local version of the dataframe before rebuilding the data. 

We pull a set of pre-selected variables that we believe will be both interesting and relevant to describing which tracts have charger access. They seek to capture information about the built environment, focusing on housing desity and ownership vs. renting, as well as demographic information, and behaviorial information as it relates to car use. While there are many additional variables that could plausibly influence charger placement, this set provides a focused and interpretable starting point.

A full list of all variables is included in the [Codebook and Dependencies](codebook.qmd) section.

In the script below, we identify our variables, and construct a helper function to pull tract level data for each state. We use `library(purrr)` to run the function over a vector of 50 states plus DC. The data is then cleaned, and additional variables are calculated, including race and ethnicity shares, as well as others related to urban form and car use. 

We then use a similar process to pull each geometry with `library(tigris)`. These geometries are joined to the ACS dataframe by `GEOID`, and the resulting dataframe is stored locally for future access. 

```{r}
if (file.exists("data/acs_clean_sf.rds") &&  !refresh_data_acs) {
  acs_clean_sf <- readr::read_rds("data/acs_clean_sf.rds")
} else {
  
  #constructing query and defining variables
  acs_year <- 2023
  acs_survey <- "acs5"
  
  acs_vars <- c(
    pop_total         = "B01003_001",  # Total pop
    
    white_nh          = "B03002_003",  # White alone, not Hispanic/Latino
    black_nh          = "B03002_004",  # Black alone, not Hispanic/Latino
    asian_nh          = "B03002_006",  # Asian alone, not Hispanic/Latino
    hispanic          = "B03002_012",  # Hispanic or Latino (any race)
    
    med_hh_income     = "B19013_001",  # Median hh income
    
    pov_total         = "B17001_001",  # Poverty universe
    pov_below         = "B17001_002",  # Below poverty
    
    lf_total          = "B23025_003",  # In labor force
    lf_unemployed     = "B23025_005",  # Unemployed
    
    occ_units_total   = "B25003_001",  # Occupied housing units
    occ_units_rent    = "B25003_003",  # Renter occupied
    
    units_total       = "B25024_001",  # Total housing units
    units_10_19       = "B25024_007",  # 10 to 19 units
    units_20_49       = "B25024_008",  # 20 to 49 units
    units_50_plus     = "B25024_009",  # 50+ units
    
    hh_vehicles_total = "B08201_001",  # Households by vehicles available
    hh_zero_veh       = "B08201_002",  # No vehicle available
    
    commute_total     = "B08301_001",  # Workers by means of transportation to work
    commute_car_alone = "B08301_003",  # Car, truck, van, drove alone
    commute_carpool   = "B08301_004"   # Car, truck, van, carpooled
  )
  
  # helper function to pull state by state
  get_state_acs <- function(state_abbr) {
    get_acs(
      geography = "tract",
      state     = state_abbr,
      year      = acs_year,
      survey    = acs_survey,
      variables = acs_vars,
      geometry  = FALSE,   # will get from TIGRIS
      output    = "wide"   
    )
  }
  
  # get list of states, pull ACS for each with purr , dropping territories
  data("fips_codes")
  
  states_vec <- unique(fips_codes$state)
  states_vec <- states_vec[!states_vec %in% c("PR", "AS", "GU", "MP", "UM", "VI")]
  
  acs_tract_raw <- purrr::map_dfr(states_vec, get_state_acs)
  
  # cleaning the data
  acs_clean <- acs_tract_raw %>%
    transmute(
      GEOID,
      name = NAME,
      
      pop_total        = pop_totalE,
      
      white_nh         = white_nhE,
      black_nh         = black_nhE,
      asian_nh         = asian_nhE,
      hispanic         = hispanicE,
      
      med_hh_income    = med_hh_incomeE,
      
      pov_total        = pov_totalE,
      pov_below        = pov_belowE,
      
      lf_total         = lf_totalE,
      lf_unemployed    = lf_unemployedE,
      
      occ_units_total  = occ_units_totalE,
      occ_units_rent   = occ_units_rentE,
      
      units_total      = units_totalE,
      units_10_19      = units_10_19E,
      units_20_49      = units_20_49E,
      units_50_plus    = units_50_plusE,
      
      hh_vehicles_total = hh_vehicles_totalE,
      hh_zero_veh       = hh_zero_vehE,
      
      commute_total     = commute_totalE,
      commute_car_alone = commute_car_aloneE,
      commute_carpool   = commute_carpoolE
    ) %>%
    mutate(
      # race shares
      pct_white_nh  = white_nh  / pop_total,
      pct_black_nh  = black_nh  / pop_total,
      pct_asian_nh  = asian_nh  / pop_total,
      pct_hispanic  = hispanic  / pop_total,
      
      # poverty rate
      pov_rate      = if_else(pov_total > 0, pov_below / pov_total, NA_real_),
      
      # unemployment rate
      unemprate     = if_else(lf_total > 0, lf_unemployed / lf_total, NA_real_),
      
      # renter share
      renter_share  = if_else(occ_units_total > 0, occ_units_rent / occ_units_total, NA_real_),
      
      # large multifamily share (relative to occupied units)
      units_10plus  = units_10_19 + units_20_49 + units_50_plus,
      multifam_share = if_else(units_total > 0, units_10plus / units_total, NA_real_),
      
      # zero vehicle households share
      zero_veh_share = if_else(hh_vehicles_total > 0, hh_zero_veh / hh_vehicles_total, NA_real_),
      
      # share commuting by car (alone plus carpool)
      commute_car_share = if_else(
        commute_total > 0,
        (commute_car_alone + commute_carpool) / commute_total,
        NA_real_
      )
    )
  
  # get geometries for tracts from TIGRIS
  get_state_tract_shapes <- function(state_abbr) {
    tracts(
      state = state_abbr,
      year  = acs_year,
      cb    = TRUE  
    )
  }
  
  tract_shapes <- purrr::map_dfr(states_vec, get_state_tract_shapes)
  
  # join geometries and demographic info 
  acs_clean_sf <- tract_shapes %>%
    left_join(acs_clean, by = "GEOID")
  
  write_rds(acs_clean_sf, "data/acs_clean_sf.rds")
}
```

## Merging and Preparing the Data Sets for Analysis

In the next step we confirm that both datasets are set to the same CRS. 

Then we perform as spatial join of the buffered charger points to the census tracts via `st_intersects`. This leaves us with one row for each tract that intersects with each charger. Because some chargers intersect with multiple tracts, and many tracts overlap with multiple chargers, the resulting dataframe has many duplicates. What we are left with is a dataframe of tract-charger pairs. Each row is a census tract, repeated for every charger that intersects with its boundaries. Using `left = TRUE`, tracts that do not intersect any buffer are retained with missing charger fields.

```{r}

acs_clean_sf_5070 <- st_transform(acs_clean_sf, st_crs(chargers_buffers_1mi)) #sets to same CRS

#joins charger buffers to tracts - tracts listed for each charger that intersects

tract_charger_pairs <- st_join(
  acs_clean_sf_5070,
  chargers_buffers_1mi %>%
    #preserve only select vars from chargers dataset
    select( 
      id,
      owner_type_code,
      facility_type,
      ev_level1_evse_num,
      ev_level2_evse_num,
      ev_connector_types,
      ev_network,
      ev_renewable_source,
      funding_sources
    ),  
  join = st_intersects,
  left = TRUE
)

```

We then condense this dataframe counting the number of unique chargers that intersect with each tract. 

Then we join these counts back to the ACS dataframe, specifying that tracts with no `chargers_accessible` value are assigned 0, as an integer. In the process, we create three additional variables: `has_charger`, a logical variable denoting any charger access, and `land_sq_miles` which we use to calculate `pop_density`. 

```{r}
#extract charger counts for each tract
tract_charger_counts <- tract_charger_pairs %>%
  st_drop_geometry() %>%       
  group_by(GEOID) %>%
  summarize(
    chargers_accessible = n_distinct(id, na.rm = TRUE),
    .groups = "drop"
  )

# join charger counts back to ACS data
#Add charger count variables, and pop_density, converting sq meters to square miles 
acs_with_access <- acs_clean_sf_5070 %>%
  left_join(tract_charger_counts, by = "GEOID") %>%
  mutate(
    chargers_accessible = replace_na(chargers_accessible, 0L),
    has_charger  = chargers_accessible > 0,
    land_sq_miles = ALAND / 2.58999e6,
    pop_density = if_else(land_sq_miles > 0, pop_total / land_sq_miles, NA_real_)
  )

```

We then create an ordered factor variable to create groups based on charger density. The rationale for this is provided in the "Exploratory Analysis" section of our main analysis. Finally we drop unneeded variables and store the final dataframe locally. 

```{r}
# create charger density categories
acs_with_access <- acs_with_access %>%
  mutate(
    charger_cat = case_when(
      chargers_accessible == 0 ~ "None",
      chargers_accessible <= 2 ~ "Very low",
      chargers_accessible <= 7 ~ "Low–moderate",
      chargers_accessible <= 19 ~ "High",
      TRUE ~ "Very high"
    ),
    charger_cat = factor(
      charger_cat,
      levels = c("None", "Very low", "Low–moderate", "High", "Very high"),
      ordered = TRUE
    )
  )

# remove unneded variables

acs_with_access <- acs_with_access %>%
  select(-NAME, -NAMELSAD, -LSAD, -STATE_NAME, -name,)

write_rds(acs_with_access, "data/acs_with_access.rds")
```
