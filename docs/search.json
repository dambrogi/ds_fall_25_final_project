[
  {
    "objectID": "main.html",
    "href": "main.html",
    "title": "Exploratory Analysis and Modeling",
    "section": "",
    "text": "library(tidyverse)\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(janitor)\nlibrary(tidycensus)\nlibrary(tigris)\nlibrary(sf)\nlibrary(rpart)\nlibrary(tidymodels)\nlibrary(rpart.plot)\nlibrary(vip)\n\nacs_with_access &lt;- readr::read_rds(\"data/acs_with_access.rds\")"
  },
  {
    "objectID": "main.html#mapping-tracts-with-and-without-ev-chargers-in-the-united-states.",
    "href": "main.html#mapping-tracts-with-and-without-ev-chargers-in-the-united-states.",
    "title": "Exploratory Analysis and Modeling",
    "section": "Mapping tracts with and without EV Chargers in the United States.",
    "text": "Mapping tracts with and without EV Chargers in the United States.\nThe following plot shows a map of the entire United States and where there is access to EV chargers and where there isn’t within the 1 mile buffer. It shows there is generally more access to chargers in urban and suburban areas and much less in rural areas. Furthermore, there is more concentration of charger access along the West Coast and Northeast, which are both highly populous areas. This maps provides a large overview of what charger access looks like across the U.S. and it is clear that chargers are more accessible in areas with more population density.\n\nggplot(acs_with_access) +\n  geom_sf(aes(fill = has_charger), color = NA) +\n  scale_fill_manual(values = c(\"TRUE\" = \"blue\", \"FALSE\" = \"red\"),\n                    labels = c(\"TRUE\" = \"Has charger access\", \"FALSE\" = \"No charger access\")) +\n  labs(\n    title = \"Census Tracts With and Without EV Charger Access (1-mile buffer)\",\n    fill = NULL\n  ) +\n  theme_minimal()"
  },
  {
    "objectID": "main.html#charger-access-in-virginia",
    "href": "main.html#charger-access-in-virginia",
    "title": "Exploratory Analysis and Modeling",
    "section": "Charger Access in Virginia",
    "text": "Charger Access in Virginia\nThe plot below takes a deeper look at the charger access map, and focuses just on the state of Virginia. It clearly shows that EV chargers are clustered in specific areas and not evenly distributed. There are high concentration of chargers in Northern Virginia, Richmond, and Virginia Beach. Furthermore, the chargers tend to cluster around interstate highways. Intuitively, this makes sense that the more popular areas tend to have more access to EV chargers.\n\nva_tracts &lt;- acs_with_access %&gt;%\n  filter(STATEFP == \"51\")\n\nggplot(va_tracts) +\n  geom_sf(aes(fill = has_charger), color = NA) +\n  scale_fill_manual(\n    values = c(\"TRUE\" = \"blue\", \"FALSE\" = \"red\"),\n    labels = c(\"TRUE\" = \"Has charger access\", \"FALSE\" = \"No charger access\")\n  ) +\n  labs(\n    title = \"Virginia Census Tracts With and Without EV Charger Access (1-mile buffer)\",\n    fill = NULL\n  ) +\n  theme_minimal()"
  },
  {
    "objectID": "main.html#charger-access-in-california",
    "href": "main.html#charger-access-in-california",
    "title": "Exploratory Analysis and Modeling",
    "section": "Charger Access in California",
    "text": "Charger Access in California\nThe other state that we looked at more deeply was California, there was a clear high access to chargers in California specifically, so it is interesting to identify where there are gaps in such a saturated area. Similar to the map of Virginia, California’s chargers are also concentrated most strongly in the Bay Area, LA, and San Diego. There is more charger clusters in rural areas such as Central Valley. California exemplifies a high investment and adoption scenario for EV chargers and can be used as a blueprint for the rest of the country.\n\nca_tracts &lt;- acs_with_access %&gt;%\n  filter(STATEFP == \"06\")\n\nggplot(ca_tracts) +\n  geom_sf(aes(fill = has_charger), color = NA) +\n  scale_fill_manual(\n    values = c(\"TRUE\" = \"blue\", \"FALSE\" = \"red\"),\n    labels = c(\"TRUE\" = \"Has charger access\", \"FALSE\" = \"No charger access\")\n  ) +\n  labs(\n    title = \"California Census Tracts With and Without EV Charger Access (1-mile buffer)\",\n    fill = NULL\n  ) +\n  theme_minimal()"
  },
  {
    "objectID": "main.html#scatter-plot-between-ev-chargers-and-population-below-poverty",
    "href": "main.html#scatter-plot-between-ev-chargers-and-population-below-poverty",
    "title": "Exploratory Analysis and Modeling",
    "section": "Scatter plot between EV Chargers and Population below Poverty",
    "text": "Scatter plot between EV Chargers and Population below Poverty\nThis last plot is a scatter plot between EV charger access and how much of the population is below the poverty line. It shows a relatively weak positive association between the two variables. The positive trend that is reflected in the plot is likely a result of more charger access in urban areas, rather than equity in distribution. Further enforces the point that there are a number of geographic factors that influence charger access and may not determined by equity.\n\nggplot(acs_with_access, aes(x = pov_below, y = chargers_accessible)) +\n  geom_point(alpha = 0.25, size = 0.7) +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  scale_y_continuous(trans = \"log1p\") +\n  labs(\n    title = \"EV Charger Access vs Population Below Poverty Line (United States)\",\n    x = \"Population Below Poverty Line\",\n    y = \"Accessible EV Chargers (log scale)\"\n  ) +\n  theme_minimal()"
  },
  {
    "objectID": "main.html#summarizing-visualizing-distribution-of-of-chargers",
    "href": "main.html#summarizing-visualizing-distribution-of-of-chargers",
    "title": "Exploratory Analysis and Modeling",
    "section": "Summarizing / Visualizing Distribution of # of Chargers",
    "text": "Summarizing / Visualizing Distribution of # of Chargers\n\nacs_with_access %&gt;%\n  ggplot(aes(x = chargers_accessible)) +\n  geom_histogram(bins = 30, fill = \"steelblue\", color = \"white\") +\n  labs(\n    title = \"Distribution of Accessible EV Chargers by Census Tract\",\n    x = \"Number of Accessible Chargers\",\n    y = \"Number of Census Tracts\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\nacs_with_access %&gt;%\n  summarize(\n    n_tracts = n(),\n    min = min(chargers_accessible, na.rm = TRUE),\n    p10 = quantile(chargers_accessible, 0.10, na.rm = TRUE),\n    p25 = quantile(chargers_accessible, 0.25, na.rm = TRUE),\n    median = median(chargers_accessible, na.rm = TRUE),\n    mean = mean(chargers_accessible, na.rm = TRUE),\n    p75 = quantile(chargers_accessible, 0.75, na.rm = TRUE),\n    p90 = quantile(chargers_accessible, 0.90, na.rm = TRUE),\n    max = max(chargers_accessible, na.rm = TRUE)\n  )\n\nSimple feature collection with 1 feature and 9 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -7115410 ymin: 269573.6 xmax: 2258200 ymax: 6198635\nProjected CRS: NAD83 / Conus Albers\n  n_tracts min p10 p25 median     mean p75 p90 max\n1    84121   0   0   0      2 8.378158   7  19 595\n                        geometry\n1 MULTIPOLYGON (((-5990266 15...\n\n\n(Explain distribution of chargers, decision to create categorical variable)\n\nsummary(acs_with_access$chargers_accessible)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  0.000   0.000   2.000   8.378   7.000 595.000 \n\n\n\nacs_with_access %&gt;%\n  ggplot(aes(x = chargers_accessible)) +\n  geom_histogram(bins = 30, fill = \"steelblue\", color = \"white\") +\n  labs(\n    title = \"Distribution of Accessible EV Chargers by Census Tract\",\n    x = \"Number of Accessible Chargers\",\n    y = \"Number of Census Tracts\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n\n\n(Add plot of charger_cat)"
  },
  {
    "objectID": "main.html#linear-model",
    "href": "main.html#linear-model",
    "title": "Exploratory Analysis and Modeling",
    "section": "Linear Model",
    "text": "Linear Model\nWe start with a simple OLS model. Here we opt for log chargers as our dependent variable, due to the long tail of in the distribution of charger counts. Because we are interested in the relative importance of our predictors, not their specific coefficients, we opt to normalise our variables for a cleaner comparison.\n\nDefining and Fitting the Model\nFirst we select a limited amount of variables as potential predictors, and eliminate other variables that may be duplicative or irrelevant. This collection of predictors is used across all three models.\n\npredictors &lt;- c(\n  \"pop_density\",\n  \"med_hh_income\",\n  \"pct_white_nh\",\n  \"pct_black_nh\",\n  \"pct_asian_nh\",\n  \"pct_hispanic\",\n  \"pov_rate\",\n  \"unemprate\",\n  \"renter_share\",\n  \"multifam_share\",\n  \"zero_veh_share\",\n  \"commute_car_share\"\n)\n\nThen we create a clean dataframe, dropping geometry, and logging the count of chargers. We then define and fit the model.\n\nlm_df &lt;- acs_with_access %&gt;%\n  sf::st_drop_geometry() %&gt;%\n  mutate(log_chargers = log1p(chargers_accessible)) %&gt;%\n  select(log_chargers, all_of(predictors)) %&gt;%\n  drop_na()\n\nlm_rec_std &lt;- recipe(log_chargers ~ ., data = lm_df) %&gt;%\n  step_normalize(all_predictors())\n\nlm_spec &lt;- linear_reg() %&gt;%\n  set_engine(\"lm\")\n\nlm_wf_std &lt;- workflow() %&gt;%\n  add_recipe(lm_rec_std) %&gt;%\n  add_model(lm_spec)\n\nlm_fit_std &lt;- fit(lm_wf_std, data = lm_df)\n\n\n\nEvaluating the Model\nBecause we use the count of chargers as our dependent variable with this model, we can’t evaluate accuracy, recall, and precision the way we do with our decision tree and LASSO models later. However, we can look at the model’s R^2 to roughtly understand how much of the variation in charger counts our model accounts for.\n\nglance(lm_fit_std) %&gt;%\n  select(r.squared, adj.r.squared, nobs)\n\n# A tibble: 1 × 3\n  r.squared adj.r.squared  nobs\n      &lt;dbl&gt;         &lt;dbl&gt; &lt;int&gt;\n1     0.407         0.407 82916\n\n\nWe see that the model captured about 41% of the variation in charger counts. Substantial, but low enough to suggest there are other variables we aren’t accounting for that play a significant role in determining counts.\n\n\nEvaluating Variable Importance\nTo evaluate the importance of our predictors, we look at their coefficients. Since they have been normalized, we can easily compare them.\n\nlm_coef_table_std &lt;- tidy(lm_fit_std) %&gt;%\n  filter(term != \"(Intercept)\") %&gt;%\n  mutate(\n    signif = case_when(\n      p.value &lt; 0.001 ~ \"***\",\n      p.value &lt; 0.01 ~ \"**\",\n      p.value &lt; 0.05 ~ \"*\",\n      p.value &lt; 0.1 ~ \"x\",\n      TRUE ~ \"\"\n    ),\n    estimate = round(estimate, 3),\n    std.error = round(std.error, 3),\n    p.value = round(p.value, 3)\n  ) %&gt;%\n  arrange(desc(abs(estimate))) %&gt;%\n  select(term, estimate, std.error, p.value, signif)\n\nlm_coef_table_std\n\n# A tibble: 12 × 5\n   term              estimate std.error p.value signif\n   &lt;chr&gt;                &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt; \n 1 renter_share         0.416     0.006   0     \"***\" \n 2 med_hh_income        0.298     0.005   0     \"***\" \n 3 commute_car_share   -0.259     0.005   0     \"***\" \n 4 multifam_share       0.235     0.005   0     \"***\" \n 5 pct_asian_nh         0.119     0.007   0     \"***\" \n 6 pop_density         -0.092     0.005   0     \"***\" \n 7 pct_hispanic         0.084     0.012   0     \"***\" \n 8 pct_black_nh        -0.055     0.011   0     \"***\" \n 9 zero_veh_share      -0.04      0.006   0     \"***\" \n10 pov_rate            -0.032     0.005   0     \"***\" \n11 unemprate            0.014     0.004   0     \"***\" \n12 pct_white_nh        -0.004     0.016   0.797 \"\"    \n\n\nWith the exception of pct_white_nh, the percentage of the tract’s population which is white (Non-Hispanic/Latino), all of our predictors are highly significant.\nA simple visualization makes the comparison more clear:\n\nplot_df_mag &lt;- tidy(lm_fit_std) %&gt;%\n  filter(term != \"(Intercept)\") %&gt;%\n  mutate(\n    mag = abs(estimate),\n  ) %&gt;%\n  arrange(mag) %&gt;%\n  mutate(term = factor(term, levels = term))\n\nlm_vi_plot &lt;- ggplot(plot_df_mag, aes(x = mag, y = term)) +\n  geom_col() +\n  labs(\n    x = \"Absolute standardized coefficient\",\n    y = \"Predictor\",\n    title = \"Standardized OLS Model\",\n    subtitle = \"Variable importance by magnitude\"\n  ) \n\nlm_vi_plot\n\n\n\n\n\n\n\n\n(Importantly, this shows the absolute value of the magintude of each coefficient, though some variables had a negative impact on number of available chargers.)\nThe variable importance results suggest that charger deployment is being driven less by simple population metrics and more by housing type, travel behavior, and market conditions. The strongest positive predictors are renter share, median household income, and multifamily housing share. This pattern is intuitive. Renters and residents of multifamily buildings are less likely to have access to private, at home charging, which increases demand for public or shared chargers. At the same time, higher income areas are more likely to attract early infrastructure investment, either because residents are more likely to own EVs or because these neighborhoods have greater resources to support deployment.\nCommute by car share plays a strongly negative role, which is consistent with the fact that our analysis focuses only on public chargers. In areas where a larger share of residents commute by car, households are more likely to have access to private parking and private chargers, reducing reliance on public infrastructure. Population density plays a smaller and negative role, suggesting that density alone does not guarantee more chargers. This makes sense, considering that in very dense urban neighborhoods, limited curb space, older infrastructure, and more complex permitting constraints can make deployment more difficult. This helps explain why both high commute by car share and high zero vehicle share are associated with fewer public chargers. On one end are tracts where private vehicles, parking, and home charging are common. On the other are dense urban tracts with fewer cars but greater physical and regulatory barriers. In both cases, demand for or feasibility of public chargers are lower.\nThe smaller effects for race, poverty, and related variables are harder to interpret directly and likely reflect broader neighborhood characteristics correlated with housing form, land use, and infrastructure conditions rather than intentional targeting."
  },
  {
    "objectID": "main.html#decision-tree-model",
    "href": "main.html#decision-tree-model",
    "title": "Exploratory Analysis and Modeling",
    "section": "Decision Tree Model",
    "text": "Decision Tree Model\n###Defining and Fitting the Model\nWe create a dataframe for use with this model, dropping grometries which are not needed for this analysis, and selecting the same set of predictors used in the previous model. We drop census tracks with NA values. We then split the data into testing and training sets.\n\ntree_model_df &lt;- acs_with_access %&gt;%\n  st_drop_geometry() %&gt;%\n  select(charger_cat, all_of(predictors)) %&gt;%\n  na.omit()\n\n# create a split object\ntree_model_df_split &lt;- initial_split(data = tree_model_df, prop = 0.75, strata = charger_cat)\n\n# create the training and testing data sets\ntree_model_df_train &lt;- training(x = tree_model_df_split)\ntree_model_df_test  &lt;- testing(x = tree_model_df_split)\n\nWe fit a classification tree using rpart and set two regularization parameters to keep the model from chasing noise. The complexity parameter (cp = 0.005) so that a split is only kept if it improves model fit by at least about 0.5%, which discourages lots of small, low-value splits and produces a tree that is easier to interpret. We also set minsplit = 250, meaning a node must contain at least 250 training observations before it can be split.\n\ntree_rec &lt;- recipe(charger_cat ~ ., data = tree_model_df_train)\n\ntree_model &lt;- decision_tree(mode = \"classification\") |&gt;\n  set_engine(\n    \"rpart\",\n    control = rpart.control(cp = 0.005, minsplit = 250)\n  )\n\ntree_wf &lt;- workflow() |&gt;\n  add_recipe(tree_rec) |&gt;\n  add_model(tree_model)\n\n# fit\nrpart_fit &lt;- tree_wf |&gt;\n  fit(data = tree_model_df_train)\n\n\nEvaluating the Model\nWe evaluate our model using the testing set, calculating precision, recall, and accuracy for both sets.\n\ntrain_preds &lt;- predict(rpart_fit, tree_model_df_train, type = \"class\") |&gt; \n  bind_cols(tree_model_df_train)\n\ntest_preds &lt;- predict(rpart_fit, tree_model_df_test, type = \"class\") |&gt; \n  bind_cols(tree_model_df_test)\n\ntree_model_metrics &lt;- tibble(\n  train_precision = precision(data = train_preds, truth = charger_cat, estimate = .pred_class)$.estimate,\n  train_recall    = recall(data = train_preds, truth = charger_cat, estimate = .pred_class)$.estimate,\n  train_accuracy  = accuracy(data = train_preds, truth = charger_cat, estimate = .pred_class)$.estimate,\n  test_precision  = precision(data = test_preds, truth = charger_cat, estimate = .pred_class)$.estimate,\n  test_recall     = recall(data = test_preds, truth = charger_cat, estimate = .pred_class)$.estimate,\n  test_accuracy   = accuracy(data = test_preds, truth = charger_cat, estimate = .pred_class)$.estimate\n)\n\ntree_model_metrics\n\n# A tibble: 1 × 6\n  train_precision train_recall train_accuracy test_precision test_recall\n            &lt;dbl&gt;        &lt;dbl&gt;          &lt;dbl&gt;          &lt;dbl&gt;       &lt;dbl&gt;\n1           0.440        0.346          0.384          0.438       0.346\n# ℹ 1 more variable: test_accuracy &lt;dbl&gt;\n\n\n(Add evaluation)\n\n\nEvaluating Variable Importance\nWe examine variable importance from the fitted classification tree to understand which features the model relies on most when splitting observations.\n\nrpart_fit |&gt;\n  extract_fit_parsnip() |&gt;\n  vip() +\n  labs(\n    title = \"Variable Importance from Decision Tree Model\",\n    y = \"Importance\",\n    x = \"Predictor\"\n  )\n\n\n\n\n\n\n\n\nIn this model, population density dominates, indicating that density is the single most useful first cut for distinguishing between tracts with very low versus nonzero charger counts. This reflects the tree’s structure. It prioritizes variables that best split the data early, rather than distributing explanatory power across a collection of variables, as in the linear model. Density likely serves as a proxy for a group of conditions that matter for charger placement, including land use, commercial activity, and overall demand.\nAfter splitting on density, the tree places greater weight on multifamily housing share and commute by car share. This suggests that once a tract clears a basic density threshold, housing form and travel behavior help explain where chargers are more likely to be deployed within similarly dense areas. Variables that were important in the linear model, such as renter share and income, appear less prominent here likely because they overlap strongly with density and housing type and add less predictive power after the initial splits.\nThe relatively small importance of most demographic variables suggests that the tree is capturing broad structural features of neighborhoods rather than narrow socioeconomic targeting. That said, the model places somewhat greater weight on a tract’s white population share. This likely reflects the role of race as a proxy for neighborhood type in a context shaped by longstanding residential segregation. White share may be picking up structural differences in neighborhood types, land use, and infrastructure that are only partially captured by variables like population density or multifamily housing share, rather than suggesting any direct discrimination in charger placement based on demographic characteristics."
  },
  {
    "objectID": "main.html#lasso-model",
    "href": "main.html#lasso-model",
    "title": "Exploratory Analysis and Modeling",
    "section": "LASSO Model",
    "text": "LASSO Model\nOur third model is a LASSO model specified as a multinomial logistic regression predicting charger density category (charger_cat). This approach allows us to examine how the importance of different tract characteristics varies across charger density levels, rather than estimating a single average relationship across the entire dataset. In addition, the LASSO penalty provides a robustness check by shrinking weaker or redundant predictors, helping highlight which variables remain important for distinguishing between charger density categories.\n\nDefining and Fitting the Model\nWe use the same collection of predictors for our LASSO model, and split the data in the same way. We also confirm that our variable charger_cat is encoded as a factor.\n\nlasso_df &lt;- acs_with_access %&gt;%\n  st_drop_geometry() %&gt;%\n  select(charger_cat, all_of(predictors)) %&gt;%\n  na.omit() %&gt;%\n  mutate(charger_cat = factor(charger_cat))\n\nset.seed(20201020)\n\nlasso_df_split &lt;- initial_split(data = lasso_df, prop = 0.75, strata = charger_cat)\n\nlasso_df_train &lt;- training(x = lasso_df_split)\nlasso_df_test &lt;- testing(x = lasso_df_split)\n\nWe define a multinomial LASSO model and estimate it using 5 fold cross validation with a 30 value tuning grid. We evaluate model performance using log loss, which accounts not only for whether the model predicts the correct category, but also how confident it is in its predictions.\n\nlasso_rec &lt;- recipe(charger_cat ~ ., data = lasso_df_train) %&gt;%\n  step_normalize(all_numeric_predictors())\n\nlasso_spec &lt;- multinom_reg(penalty = tune(), mixture = 1)%&gt;%\n  set_engine(\"glmnet\")\n\nlasso_wf &lt;- workflow() %&gt;%\n  add_recipe(lasso_rec) %&gt;%\n  add_model(lasso_spec)\n\nfolds &lt;- vfold_cv(lasso_df_train, v = 5, strata = charger_cat)\n\nlambda_grid &lt;- grid_regular(penalty(), levels = 30)\n\nlasso_tuned &lt;- tune_grid(\n  lasso_wf,\n  resamples = folds,\n  grid = lambda_grid,\n  metrics = metric_set(accuracy, mn_log_loss)\n)\n\nbest_lambda &lt;- select_best(\n  lasso_tuned,\n  metric = \"mn_log_loss\"\n)\n\nNotably, our optimal lambda is very small at 0.0000000001. This suggests our predictors are already doing a good job explaining charger categories require only minimal regularization.\n\nbest_lambda\n\n# A tibble: 1 × 2\n       penalty .config         \n         &lt;dbl&gt; &lt;chr&gt;           \n1 0.0000000001 pre0_mod01_post0\n\nautoplot(lasso_tuned)\n\n\n\n\n\n\n\n\nWe then fit the model and store its predictions for evaluation.\n\nfinal_lasso &lt;- finalize_workflow(lasso_wf, best_lambda) %&gt;%\n  fit(data = lasso_df_train)\n\nlasso_train_preds &lt;- predict(final_lasso, lasso_df_train, type = \"class\") %&gt;%\n  bind_cols(lasso_df_train)\n\nlasso_test_preds &lt;- predict(final_lasso, lasso_df_test, type = \"class\") %&gt;%\n  bind_cols(lasso_df_test)\n\n\n\nEvaluating the Model\n\nlasso_model_metrics &lt;- tibble(\n  train_precision = precision(lasso_train_preds, truth = charger_cat, estimate = .pred_class)$.estimate,\n  train_recall    = recall(lasso_train_preds, truth = charger_cat, estimate = .pred_class)$.estimate,\n  test_precision  = precision(lasso_test_preds, truth = charger_cat, estimate = .pred_class)$.estimate,\n  test_recall     = recall(lasso_test_preds, truth = charger_cat, estimate = .pred_class)$.estimate,\n  train_accuracy  = accuracy(lasso_train_preds, truth = charger_cat, estimate = .pred_class)$.estimate,\n  test_accuracy   = accuracy(lasso_test_preds, truth = charger_cat, estimate = .pred_class)$.estimate\n)\n\nlasso_model_metrics\n\n# A tibble: 1 × 6\n  train_precision train_recall test_precision test_recall train_accuracy\n            &lt;dbl&gt;        &lt;dbl&gt;          &lt;dbl&gt;       &lt;dbl&gt;          &lt;dbl&gt;\n1           0.376        0.372          0.369       0.373          0.399\n# ℹ 1 more variable: test_accuracy &lt;dbl&gt;\n\n\nThough its performance is modest, results are consistent across the training and test sets, suggesting that the model is not overfitting. Notably, accuracy is similar to that of the decision tree model and to the R^2 from the linear specification. While these metrics are not directly comparable, their similarity suggests that we may be reaching the limits of what our selected predictors can explain about charger deployment.\n\n\nEvaluating Variable Importance\nBecause our dependent variable is categorical, the model estimates separate coefficients for each charger density category. The table below reports coefficient estimates for all predictors across the five charger density categories.\n\ncoef_tbl &lt;- final_lasso %&gt;%\n  extract_fit_parsnip() %&gt;%\n  tidy() %&gt;%\n  select(class, term, estimate) %&gt;%\n  filter(term != \"(Intercept)\") %&gt;%\n  group_by(class) %&gt;%\n  arrange(desc(abs(estimate)), .by_group = TRUE) %&gt;%\n  print(n=60)\n\n# A tibble: 60 × 3\n# Groups:   class [5]\n   class        term               estimate\n   &lt;chr&gt;        &lt;chr&gt;                 &lt;dbl&gt;\n 1 High         renter_share       0.355   \n 2 High         commute_car_share -0.256   \n 3 High         med_hh_income      0.230   \n 4 High         multifam_share     0.125   \n 5 High         pct_asian_nh       0.108   \n 6 High         pov_rate          -0.100   \n 7 High         pct_hispanic       0.0898  \n 8 High         zero_veh_share    -0.0332  \n 9 High         pct_black_nh      -0.0324  \n10 High         unemprate          0.00826 \n11 High         pct_white_nh       0.000204\n12 High         pop_density        0       \n13 Low–moderate pop_density        0.149   \n14 Low–moderate pov_rate          -0.0636  \n15 Low–moderate zero_veh_share     0.0292  \n16 Low–moderate med_hh_income      0       \n17 Low–moderate pct_white_nh       0       \n18 Low–moderate pct_black_nh       0       \n19 Low–moderate pct_asian_nh       0       \n20 Low–moderate pct_hispanic       0       \n21 Low–moderate unemprate          0       \n22 Low–moderate renter_share       0       \n23 Low–moderate multifam_share     0       \n24 Low–moderate commute_car_share  0       \n25 None         renter_share      -0.693   \n26 None         multifam_share    -0.645   \n27 None         med_hh_income     -0.485   \n28 None         pop_density       -0.441   \n29 None         pct_asian_nh      -0.384   \n30 None         commute_car_share  0.374   \n31 None         pct_hispanic      -0.139   \n32 None         pov_rate           0.100   \n33 None         pct_black_nh       0.0739  \n34 None         pct_white_nh      -0.0152  \n35 None         unemprate         -0.00979 \n36 None         zero_veh_share     0       \n37 Very high    renter_share       0.883   \n38 Very high    med_hh_income      0.635   \n39 Very high    commute_car_share -0.541   \n40 Very high    pct_black_nh      -0.391   \n41 Very high    multifam_share     0.346   \n42 Very high    pct_white_nh      -0.193   \n43 Very high    pop_density       -0.107   \n44 Very high    pct_asian_nh       0.106   \n45 Very high    zero_veh_share    -0.0669  \n46 Very high    unemprate          0.0247  \n47 Very high    pct_hispanic       0       \n48 Very high    pov_rate           0       \n49 Very low     renter_share      -0.344   \n50 Very low     pop_density        0.260   \n51 Very low     multifam_share    -0.225   \n52 Very low     med_hh_income     -0.215   \n53 Very low     commute_car_share  0.203   \n54 Very low     pct_asian_nh      -0.0986  \n55 Very low     pct_black_nh       0.0607  \n56 Very low     pct_hispanic      -0.0530  \n57 Very low     pov_rate           0.0300  \n58 Very low     pct_white_nh       0.0211  \n59 Very low     zero_veh_share     0.0199  \n60 Very low     unemprate         -0.00649 \n\n\nThese results largely reinforce the patterns we saw in the linear and tree based models, while adding more detail about how different variables matter at different points along the charger density spectrum. The clearest structure appears at the extremes. Tracts with no chargers are strongly characterized by lower renter share, lower multifamily housing share, lower income, and lower density, alongside higher commute by car share. In other words, places with predominantly single family housing, private vehicles, and private parking are systematically less likely to host public chargers. On the opposite end, very high charger density tracts show the mirror image of this pattern: higher renter share, higher income, more multifamily housing, and lower commute by car share. These are precisely the environments where demand for shared charging is highest and deployment is most feasible, which aligns closely with our earlier interpretations.\nThe middle categories are notably less structured. For the low–moderate category in particular, most coefficients are reduced to zero, suggesting that the intermediate levels of charger density are harder to explain using tract level characteristics.\nThe plot below visualizes these coefficients, showing both the average and maximum coefficient across classes.\n\nlasso_viz_df &lt;- coef_tbl %&gt;%\n  filter(term != \"(Intercept)\") %&gt;%\n  group_by(term) %&gt;%\n  summarise(\n    max_abs_coef  = max(abs(estimate)),\n    mean_abs_coef = mean(abs(estimate)),\n    .groups = \"drop\"\n  ) %&gt;%\n  arrange(desc(max_abs_coef))\n\nlasso_viz_long &lt;- lasso_viz_df %&gt;%\n  pivot_longer(\n    cols = c(max_abs_coef, mean_abs_coef),\n    names_to = \"metric\",\n    values_to = \"value\"\n  )\n\nlasso_viz &lt;- ggplot(lasso_viz_long,\n       aes(x = reorder(term, value), y = value, fill = metric)) +\n  geom_col(position = \"dodge\") +\n  coord_flip() +\n  labs(\n    title = \"LASSO coefficient magnitude by predictor\",\n    x = NULL,\n    y = \"Absolute coefficient value\",\n    fill = NULL\n  ) +\n  theme_minimal()\n\nlasso_viz"
  },
  {
    "objectID": "main.html#discussion",
    "href": "main.html#discussion",
    "title": "Exploratory Analysis and Modeling",
    "section": "Discussion",
    "text": "Discussion\n(Add discussion)"
  },
  {
    "objectID": "codebook.html",
    "href": "codebook.html",
    "title": "Codebook and Dependencies",
    "section": "",
    "text": "Dependencies\nThe following packages are needed to execute the code in this document:\n\nlibrary(tidyverse)\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(janitor)\nlibrary(tidycensus)\nlibrary(tigris)\nlibrary(sf)\nlibrary(rpart)\nlibrary(tidymodels)\nlibrary(rpart.plot)\nlibrary(vip)\n\nAdditionally, a Census API key and an NREL API key are required for this project. Both must be stored in your .Renv, with the NREL key stored as NREL_API_KEY='yourkey'.\n\n\nCodebook\nThe main dataset used in our analysis is the dataframe acs_with_access.\nIt contains all census tracts in the US (including DC, excluding PR and other territories), and the variables listed in the table below.\nVariables related to charger accessibility include only public EV chargers. A charger is considered accessible if it is located within one mile of a census tract boundary.\n\n\n\n\n\n\n\n\nVariable\nFormat\nMeaning\n\n\n\n\nSTATEFP\ncharacter\nState FIPS\n\n\nCOUNTYFP\ncharacter\nCounty FIPS\n\n\nTRACTCE\ncharacter\nTract code\n\n\nGEOIDFQ\ncharacter\nFully qualified tract geo identifier\n\n\nGEOID\ncharacter\nCensus tract geo identifier\n\n\nSTUSPS\ncharacter\nState postal code\n\n\nALAND\nnumeric\nTract land area in square meters\n\n\nAWATER\nnumeric\nTract water area in square meters\n\n\npop_total\nnumeric\nTotal tract pop\n\n\nwhite_nh\nnumeric\nWhite non Hispanic / Latino pop\n\n\nblack_nh\nnumeric\nBlack non Hispanic / Latino pop\n\n\nasian_nh\nnumeric\nAsian non Hispanic / Latino pop\n\n\nhispanic\nnumeric\nHispanic or Latino (any race) pop\n\n\nmed_hh_income\nnumeric\nMedian household income\n\n\npov_total\nnumeric\nPoverty universe\n\n\npov_below\nnumeric\nPop below poverty line\n\n\nlf_total\nnumeric\nLabor force total\n\n\nlf_unemployed\nnumeric\nUnemployed pop\n\n\nocc_units_total\nnumeric\nTotal occupied housing units\n\n\nocc_units_rent\nnumeric\nTotal renter occupied housing units\n\n\nunits_10_19\nnumeric\nUnits in 10 to 19 unit buildings\n\n\nunits_20_49\nnumeric\nUnits in 20 to 29 unit buildings\n\n\nunits_50_plus\nnumeric\nUnits in 50+ unit buildings\n\n\nunits_10plus\nnumeric\nTotal units in large multifamily\n\n\nhh_vehicles_total\nnumeric\nHoushold vehicles universe\n\n\nhh_zero_veh\nnumeric\nHouseholds with 0 vehicle access\n\n\ncommute_total\nnumeric\nCommuter universe\n\n\ncommute_car_alone\nnumeric\nPop that commute in car alone\n\n\ncommute_carpool\nnumeric\nPop that commutes (carpool)\n\n\npct_white_nh\nnumeric\nWhite nh share\n\n\npct_black_nh\nnumeric\nBlack nh share\n\n\npct_asian_nh\nnumeric\nAsian nh share\n\n\npct_hispanic\nnumeric\nHispanic (any race) share\n\n\npov_rate\nnumeric\nPoverty rate\n\n\nunemprate\nnumeric\nUnemployment rate\n\n\nrenter_share\nnumeric\nRenter share\n\n\nmultifam_share\nnumeric\nMultifamily housing share\n\n\nzero_veh_share\nnumeric\nZero vehicle access share\n\n\ncommute_car_share\nnumeric\nCar commuter share\n\n\nland_sq_miles\nnumeric\nTract land area in sq. miles\n\n\npop_density\nnumeric\nPopulation density (pop_total/land_sq_miles)\n\n\nchargers_accessible\nnumeric\nNumber of chargers accessible (1 mile buffer)\n\n\nhas_charger\nlogical\nTrue if chargers &gt; 0 for the tract, false if no charger available\n\n\ncharger_cat\nordered factor\nCharger density category: “None” (0), “Very low” (1-2), “Low–moderate” (3-6), “High” (7-18), or “Very high” (18+)\n\n\ngeometry\nsfc_MULTIPOLYGON\nTract geometry (polygon)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Electric vehicles (EVs) usage is on the rise as more Americans become more aware of the state of climate change and become more environmentally conscious. However, this transition is only effective if there is appropriate infrastructure for it. There must be enough charging stations accessible to the public for this to be both an effective and efficient transition. Furthermore, as this transition is in the early stages, it is critical to create an infrastructure that is fair and equal amongst different socioeconomic areas across the United States.\nThis project aims to look into a simple but important question: Are public EV charging stations fairly distributed across different kinds of neighborhoods, or are some communities being left behind? Charger locations in the United States are shaped by a mix of forces including market incentives, local zoning rules, corporate partnerships, and state and federal subsidies. As a result, the geographic pattern of EV chargers may reflect structural advantages rather than purely consumer needs. This project will examine whether those forces collectively produce unequal access to charging.\nTo investigate this issue, we combine data from two primary sources. First, we use the U.S. Department of Energy’s public API, which provides detailed information on the locations and types of public EV charging stations nationwide. Second, we merge this information with census-tract-level demographic and housing data from the American Community Survey, including measures of income, race, population size, and commuter patterns. Combined, this creates a comprehensive dataset that allows us to analyze charger availability in neighborhoods across the country and differentiate between different socioeconomic conditions.\nWe then use visualizations do some precursory exploration of the dataset, including mapping certain regionas and exploring how charger access interacts with select demographic characteristics.\nBuilding on this exploratory work, we estimate a series of models to identify which neighborhood characteristics are most strongly associated with charger access. We begin with a standardized linear regression to assess relative predictor importance for charger counts, followed by a classification decision tree to capture nonlinear relationships and threshold effects. Finally, we fit a multinomial LASSO model to examine how predictors differ across charger density categories while reducing noise from correlated variables. Across these approaches, we use techniques including feature engineering, normalization, cross validation, regularization, model comparison, and variable importance analysis. Together, these methods allow us to move beyond simple correlations and better understand the structural factors shaping where public EV charging infrastructure is deployed.\nThe analysis proceeds in three parts, each documented below.\nThe recommended reading order is: 1. Codebook and Dependencies 2. Data Assembly and Cleaning 3. Exploratory Analysis and Modeling\n\n\nCodebook and Dependencies\nThis section explains the libraries used and other steps needed to recreate our analysis. It also contains an overview of all variables in our main data set.\n➡️ Codebook and Dependencies\n\n\n\nData Assembly and Cleaning\nThis section walks through the steps we took to assemble our main dataset.\nIt explains how raw inputs are transformed into the final tract-level dataset used in exploratory analysis and modeling.\n➡️ Data Assembly and Cleaning\n\n\n\nExploratory Analysis and Modeling\nThis section presents descriptive analysis, visual exploration, and statistical modeling results. It examines patterns in charger access and evaluates which factors are most strongly associated with observed deployment outcomes.\nModeling choices, diagnostics, and interpretation are discussed in detail.\n➡️ Exploratory Analysis and Modeling"
  },
  {
    "objectID": "assembly.html",
    "href": "assembly.html",
    "title": "Data Assembly and Cleaning",
    "section": "",
    "text": "Our EV charger location data comes from the National Renewable Energy Laboratory’s (NREL) alternative fuel stations database API. The publicly available database lists all public and private EV chargers in the U.S, including their latitude and longitude. We supplement this data with demographic variables from the 5 year American Community Survey, accessed via the Census API via tidycensus."
  },
  {
    "objectID": "assembly.html#data-sources",
    "href": "assembly.html#data-sources",
    "title": "Data Assembly and Cleaning",
    "section": "",
    "text": "Our EV charger location data comes from the National Renewable Energy Laboratory’s (NREL) alternative fuel stations database API. The publicly available database lists all public and private EV chargers in the U.S, including their latitude and longitude. We supplement this data with demographic variables from the 5 year American Community Survey, accessed via the Census API via tidycensus."
  },
  {
    "objectID": "assembly.html#pulling-the-nrel-charger-data",
    "href": "assembly.html#pulling-the-nrel-charger-data",
    "title": "Data Assembly and Cleaning",
    "section": "Pulling the NREL Charger Data",
    "text": "Pulling the NREL Charger Data\n\n#load libraries\nlibrary(tidyverse)\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(janitor)\nlibrary(tidycensus)\nlibrary(tigris)\nlibrary(sf)\n\nBecause we are dealing with a large data set and several API calls, the following code is wrapped in if statements, such that API calls will only be made if the data is not already stored on locally. refresh_data_chargers and refresh_data_acs allow for a manual override.\nData is stored in the subdirectory /data, which is created if it doesn’t exist already.\n\nif (!dir.exists(\"data\")) dir.create(\"data\")\n\nrefresh_data_chargers &lt;-FALSE # set to TRUE to re-pull charger data\nrefresh_data_acs &lt;- FALSE # set to TRUE if to re-pull ACS data\n\nThe code block below loads the API key and constructs a GET call to collect data on all public AV chargers in the US. In addition to their locations, the query also selects several variables about the chargers, which we ultimately did not end up using in this analysis.\nAfter confirming a successful response, the incoming JSON is parsed and converted into a dataframe, chargers. The latitude and longitude of each charger are then used to create point geometries. The coordinate reference system is reprojected to EPSG:5070 to allow distance calculations in meters. Buffers are applied around each charger point to account for the fact that chargers can serve nearby census tracts even when they do not fall directly within tract boundaries. We use a 1-mile buffer to define access, consistent with NEVI guidelines that place corridor fast chargers within 1 mile of a highway. Anchoring the buffer to this standard avoids an arbitrary cutoff and makes the access measure easier to interpret.\nThe resulting dataframe is then stored locally for future access.\n\nif (file.exists(\"data/chargers_sf.rds\") && \n    file.exists(\"data/chargers_buffers_1mi.rds\") && \n    !refresh_data_chargers)\n{\n  chargers_sf &lt;- read_rds(\"data/chargers_sf.rds\")\n  chargers_buffers_1mi &lt;- read_rds(\"data/chargers_buffers_1mi.rds\")\n} else {\n  \n  #Read API Key from env file\n  nrel_key &lt;- Sys.getenv(\"NREL_API_KEY\")\n  \n  # Build and Send Request\n  base_url &lt;- \"https://developer.nrel.gov/api/alt-fuel-stations/v1.json\"\n  \n  params &lt;- list(\n    api_key = nrel_key,\n    fuel_type = \"ELEC\", # electric\n    access = \"public\", # public access_code\n    country = \"US\", # US stations\n    status = \"E\", # only available stations\n    limit  = \"all\" \n  )\n  \n  chargers_json &lt;- GET(base_url, query = params)\n  \n  # Check the response\n  http_status(chargers_json)\n  \n  #parse the response\n  chargers_text_json &lt;- content(chargers_json, as = \"text\")\n  chargers_parsed_json &lt;- fromJSON(chargers_text_json, flatten = TRUE)\n  chargers &lt;- as_tibble(chargers_parsed_json$fuel_stations)\n  \n  chargers &lt;- chargers |&gt;\n    select(\n      id,\n      station_name,\n      street_address,\n      city, \n      state,\n      zip,\n      plus4,\n      restricted_access,\n      access_detail_code,\n      owner_type_code,\n      facility_type,\n      ev_level1_evse_num,\n      ev_level2_evse_num,\n      ev_connector_types,\n      ev_network,\n      ev_renewable_source,\n      funding_sources,\n      geocode_status,\n      latitude,\n      longitude,\n      open_date\n    )\n  \n  # turn latitude and longitude into geometries\n  chargers_sf &lt;- chargers |&gt;\n    # drop rows with missing coords\n    filter(!is.na(latitude), !is.na(longitude)) |&gt;\n    st_as_sf(\n      coords = c(\"longitude\", \"latitude\"),  \n      crs    = 4326,                        \n      remove = FALSE                       \n    )\n  \n  chargers_sf &lt;- st_transform(chargers_sf, 5070) #change to projected CRS in meters, for buffers\n  \n  chargers_buffers_1mi &lt;- st_buffer(chargers_sf, dist = 1609.34) #creates one mile buffers\n  \n  #cache locally to avoid repeat pulls\n  write_rds(chargers_sf, \"data/chargers_sf.rds\")\n  write_rds(chargers_buffers_1mi, \"data/chargers_buffers_1mi.rds\")\n}"
  },
  {
    "objectID": "assembly.html#pulling-the-acs-data-and-tract-geometries",
    "href": "assembly.html#pulling-the-acs-data-and-tract-geometries",
    "title": "Data Assembly and Cleaning",
    "section": "Pulling the ACS Data and Tract Geometries",
    "text": "Pulling the ACS Data and Tract Geometries\nWe then construct a tract-level demographic dataset from the 2023 ACS 5-year survey to provide additional demographic information about each census tract. Again we check for a previous local version of the dataframe before rebuilding the data.\nWe pull a set of pre-selected variables that we believe will be both interesting and relevant to describing which tracts have charger access. They seek to capture information about the built environment, focusing on housing desity and ownership vs. renting, as well as demographic information, and behaviorial information as it relates to car use. While there are many additional variables that could plausibly influence charger placement, this set provides a focused and interpretable starting point.\nA full list of all variables is included in the Codebook and Dependencies section.\nIn the script below, we identify our variables, and construct a helper function to pull tract level data for each state. We use library(purrr) to run the function over a vector of 50 states plus DC. The data is then cleaned, and additional variables are calculated, including race and ethnicity shares, as well as others related to urban form and car use.\nWe then use a similar process to pull each geometry with library(tigris). These geometries are joined to the ACS dataframe by GEOID, and the resulting dataframe is stored locally for future access.\n\nif (file.exists(\"data/acs_clean_sf.rds\") &&  !refresh_data_acs) {\n  acs_clean_sf &lt;- readr::read_rds(\"data/acs_clean_sf.rds\")\n} else {\n  \n  #constructing query and defining variables\n  acs_year &lt;- 2023\n  acs_survey &lt;- \"acs5\"\n  \n  acs_vars &lt;- c(\n    pop_total         = \"B01003_001\",  # Total pop\n    \n    white_nh          = \"B03002_003\",  # White alone, not Hispanic/Latino\n    black_nh          = \"B03002_004\",  # Black alone, not Hispanic/Latino\n    asian_nh          = \"B03002_006\",  # Asian alone, not Hispanic/Latino\n    hispanic          = \"B03002_012\",  # Hispanic or Latino (any race)\n    \n    med_hh_income     = \"B19013_001\",  # Median hh income\n    \n    pov_total         = \"B17001_001\",  # Poverty universe\n    pov_below         = \"B17001_002\",  # Below poverty\n    \n    lf_total          = \"B23025_003\",  # In labor force\n    lf_unemployed     = \"B23025_005\",  # Unemployed\n    \n    occ_units_total   = \"B25003_001\",  # Occupied housing units\n    occ_units_rent    = \"B25003_003\",  # Renter occupied\n    \n    units_total       = \"B25024_001\",  # Total housing units\n    units_10_19       = \"B25024_007\",  # 10 to 19 units\n    units_20_49       = \"B25024_008\",  # 20 to 49 units\n    units_50_plus     = \"B25024_009\",  # 50+ units\n    \n    hh_vehicles_total = \"B08201_001\",  # Households by vehicles available\n    hh_zero_veh       = \"B08201_002\",  # No vehicle available\n    \n    commute_total     = \"B08301_001\",  # Workers by means of transportation to work\n    commute_car_alone = \"B08301_003\",  # Car, truck, van, drove alone\n    commute_carpool   = \"B08301_004\"   # Car, truck, van, carpooled\n  )\n  \n  # helper function to pull state by state\n  get_state_acs &lt;- function(state_abbr) {\n    get_acs(\n      geography = \"tract\",\n      state     = state_abbr,\n      year      = acs_year,\n      survey    = acs_survey,\n      variables = acs_vars,\n      geometry  = FALSE,   # will get from TIGRIS\n      output    = \"wide\"   \n    )\n  }\n  \n  # get list of states, pull ACS for each with purr , dropping territories\n  data(\"fips_codes\")\n  \n  states_vec &lt;- unique(fips_codes$state)\n  states_vec &lt;- states_vec[!states_vec %in% c(\"PR\", \"AS\", \"GU\", \"MP\", \"UM\", \"VI\")]\n  \n  acs_tract_raw &lt;- purrr::map_dfr(states_vec, get_state_acs)\n  \n  # cleaning the data\n  acs_clean &lt;- acs_tract_raw %&gt;%\n    transmute(\n      GEOID,\n      name = NAME,\n      \n      pop_total        = pop_totalE,\n      \n      white_nh         = white_nhE,\n      black_nh         = black_nhE,\n      asian_nh         = asian_nhE,\n      hispanic         = hispanicE,\n      \n      med_hh_income    = med_hh_incomeE,\n      \n      pov_total        = pov_totalE,\n      pov_below        = pov_belowE,\n      \n      lf_total         = lf_totalE,\n      lf_unemployed    = lf_unemployedE,\n      \n      occ_units_total  = occ_units_totalE,\n      occ_units_rent   = occ_units_rentE,\n      \n      units_total      = units_totalE,\n      units_10_19      = units_10_19E,\n      units_20_49      = units_20_49E,\n      units_50_plus    = units_50_plusE,\n      \n      hh_vehicles_total = hh_vehicles_totalE,\n      hh_zero_veh       = hh_zero_vehE,\n      \n      commute_total     = commute_totalE,\n      commute_car_alone = commute_car_aloneE,\n      commute_carpool   = commute_carpoolE\n    ) %&gt;%\n    mutate(\n      # race shares\n      pct_white_nh  = white_nh  / pop_total,\n      pct_black_nh  = black_nh  / pop_total,\n      pct_asian_nh  = asian_nh  / pop_total,\n      pct_hispanic  = hispanic  / pop_total,\n      \n      # poverty rate\n      pov_rate      = if_else(pov_total &gt; 0, pov_below / pov_total, NA_real_),\n      \n      # unemployment rate\n      unemprate     = if_else(lf_total &gt; 0, lf_unemployed / lf_total, NA_real_),\n      \n      # renter share\n      renter_share  = if_else(occ_units_total &gt; 0, occ_units_rent / occ_units_total, NA_real_),\n      \n      # large multifamily share (relative to occupied units)\n      units_10plus  = units_10_19 + units_20_49 + units_50_plus,\n      multifam_share = if_else(units_total &gt; 0, units_10plus / units_total, NA_real_),\n      \n      # zero vehicle households share\n      zero_veh_share = if_else(hh_vehicles_total &gt; 0, hh_zero_veh / hh_vehicles_total, NA_real_),\n      \n      # share commuting by car (alone plus carpool)\n      commute_car_share = if_else(\n        commute_total &gt; 0,\n        (commute_car_alone + commute_carpool) / commute_total,\n        NA_real_\n      )\n    )\n  \n  # get geometries for tracts from TIGRIS\n  get_state_tract_shapes &lt;- function(state_abbr) {\n    tracts(\n      state = state_abbr,\n      year  = acs_year,\n      cb    = TRUE  \n    )\n  }\n  \n  tract_shapes &lt;- purrr::map_dfr(states_vec, get_state_tract_shapes)\n  \n  # join geometries and demographic info \n  acs_clean_sf &lt;- tract_shapes %&gt;%\n    left_join(acs_clean, by = \"GEOID\")\n  \n  write_rds(acs_clean_sf, \"data/acs_clean_sf.rds\")\n}"
  },
  {
    "objectID": "assembly.html#merging-and-preparing-the-data-sets-for-analysis",
    "href": "assembly.html#merging-and-preparing-the-data-sets-for-analysis",
    "title": "Data Assembly and Cleaning",
    "section": "Merging and Preparing the Data Sets for Analysis",
    "text": "Merging and Preparing the Data Sets for Analysis\nIn the next step we confirm that both datasets are set to the same CRS.\nThen we perform as spatial join of the buffered charger points to the census tracts via st_intersects. This leaves us with one row for each tract that intersects with each charger. Because some chargers intersect with multiple tracts, and many tracts overlap with multiple chargers, the resulting dataframe has many duplicates. What we are left with is a dataframe of tract-charger pairs. Each row is a census tract, repeated for every charger that intersects with its boundaries. Using left = TRUE, tracts that do not intersect any buffer are retained with missing charger fields.\n\nacs_clean_sf_5070 &lt;- st_transform(acs_clean_sf, st_crs(chargers_buffers_1mi)) #sets to same CRS\n\n#joins charger buffers to tracts - tracts listed for each charger that intersects\n\ntract_charger_pairs &lt;- st_join(\n  acs_clean_sf_5070,\n  chargers_buffers_1mi %&gt;%\n    #preserve only select vars from chargers dataset\n    select( \n      id,\n      owner_type_code,\n      facility_type,\n      ev_level1_evse_num,\n      ev_level2_evse_num,\n      ev_connector_types,\n      ev_network,\n      ev_renewable_source,\n      funding_sources\n    ),  \n  join = st_intersects,\n  left = TRUE\n)\n\nWe then condense this dataframe counting the number of unique chargers that intersect with each tract.\nThen we join these counts back to the ACS dataframe, specifying that tracts with no chargers_accessible value are assigned 0, as an integer. In the process, we create three additional variables: has_charger, a logical variable denoting any charger access, and land_sq_miles which we use to calculate pop_density.\n\n#extract charger counts for each tract\ntract_charger_counts &lt;- tract_charger_pairs %&gt;%\n  st_drop_geometry() %&gt;%       \n  group_by(GEOID) %&gt;%\n  summarize(\n    chargers_accessible = n_distinct(id, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\n# join charger counts back to ACS data\n#Add charger count variables, and pop_density, converting sq meters to square miles \nacs_with_access &lt;- acs_clean_sf_5070 %&gt;%\n  left_join(tract_charger_counts, by = \"GEOID\") %&gt;%\n  mutate(\n    chargers_accessible = replace_na(chargers_accessible, 0L),\n    has_charger  = chargers_accessible &gt; 0,\n    land_sq_miles = ALAND / 2.58999e6,\n    pop_density = if_else(land_sq_miles &gt; 0, pop_total / land_sq_miles, NA_real_)\n  )\n\nWe then create an ordered factor variable to create groups based on charger density. The rationale for this is provided in the “Exploratory Analysis” section of our main analysis. Finally we drop unneeded variables and store the final dataframe locally.\n\n# create charger density categories\nacs_with_access &lt;- acs_with_access %&gt;%\n  mutate(\n    charger_cat = case_when(\n      chargers_accessible == 0 ~ \"None\",\n      chargers_accessible &lt;= 2 ~ \"Very low\",\n      chargers_accessible &lt;= 7 ~ \"Low–moderate\",\n      chargers_accessible &lt;= 19 ~ \"High\",\n      TRUE ~ \"Very high\"\n    ),\n    charger_cat = factor(\n      charger_cat,\n      levels = c(\"None\", \"Very low\", \"Low–moderate\", \"High\", \"Very high\"),\n      ordered = TRUE\n    )\n  )\n\n# remove unneded variables\n\nacs_with_access &lt;- acs_with_access %&gt;%\n  select(-NAME, -NAMELSAD, -LSAD, -STATE_NAME, -name,)\n\nwrite_rds(acs_with_access, \"data/acs_with_access.rds\")"
  }
]